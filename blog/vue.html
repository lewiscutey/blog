<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一文速览Vue全栈 | HOME</title>
    <meta name="description" content="本文简单介绍了vue全栈">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="keywords" content="vue、vuex、vue-router">
    <link rel="preload" href="/blog/assets/css/0.styles.03f43f65.css" as="style"><link rel="preload" href="/blog/assets/js/app.426b1919.js" as="script"><link rel="preload" href="/blog/assets/js/8.723e2475.js" as="script"><link rel="preload" href="/blog/assets/js/3.79418191.js" as="script"><link rel="preload" href="/blog/assets/js/16.d48bf774.js" as="script"><link rel="preload" href="/blog/assets/js/19.ff47a288.js" as="script"><link rel="preload" href="/blog/assets/js/13.7908793c.js" as="script"><link rel="preload" href="/blog/assets/js/64.fcc0d5d9.js" as="script"><link rel="preload" href="/blog/assets/js/5.da195e96.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.55a543e4.js"><link rel="prefetch" href="/blog/assets/js/11.e5597df6.js"><link rel="prefetch" href="/blog/assets/js/12.b7ba11c7.js"><link rel="prefetch" href="/blog/assets/js/14.4410875d.js"><link rel="prefetch" href="/blog/assets/js/15.b657430a.js"><link rel="prefetch" href="/blog/assets/js/17.eeefbc07.js"><link rel="prefetch" href="/blog/assets/js/18.010cd5bc.js"><link rel="prefetch" href="/blog/assets/js/20.d0f52bb3.js"><link rel="prefetch" href="/blog/assets/js/21.9bea050c.js"><link rel="prefetch" href="/blog/assets/js/22.ee11d625.js"><link rel="prefetch" href="/blog/assets/js/23.6e634148.js"><link rel="prefetch" href="/blog/assets/js/24.e0f856db.js"><link rel="prefetch" href="/blog/assets/js/25.f97f7d33.js"><link rel="prefetch" href="/blog/assets/js/26.7681393f.js"><link rel="prefetch" href="/blog/assets/js/27.102f400b.js"><link rel="prefetch" href="/blog/assets/js/28.46c69e24.js"><link rel="prefetch" href="/blog/assets/js/29.bb64475f.js"><link rel="prefetch" href="/blog/assets/js/30.12416738.js"><link rel="prefetch" href="/blog/assets/js/31.7cc64602.js"><link rel="prefetch" href="/blog/assets/js/32.175d94de.js"><link rel="prefetch" href="/blog/assets/js/33.89a17daf.js"><link rel="prefetch" href="/blog/assets/js/34.a0106064.js"><link rel="prefetch" href="/blog/assets/js/35.970f9d7e.js"><link rel="prefetch" href="/blog/assets/js/36.fa8d9d4e.js"><link rel="prefetch" href="/blog/assets/js/37.93b81ade.js"><link rel="prefetch" href="/blog/assets/js/38.f242f2da.js"><link rel="prefetch" href="/blog/assets/js/39.91d1d0fb.js"><link rel="prefetch" href="/blog/assets/js/4.acd5b20f.js"><link rel="prefetch" href="/blog/assets/js/40.ec8fc8a2.js"><link rel="prefetch" href="/blog/assets/js/41.51829cee.js"><link rel="prefetch" href="/blog/assets/js/42.5614ec93.js"><link rel="prefetch" href="/blog/assets/js/43.eb03efc3.js"><link rel="prefetch" href="/blog/assets/js/44.c9e2f6ff.js"><link rel="prefetch" href="/blog/assets/js/45.0a9bbd19.js"><link rel="prefetch" href="/blog/assets/js/46.27f8e029.js"><link rel="prefetch" href="/blog/assets/js/47.1e0af253.js"><link rel="prefetch" href="/blog/assets/js/48.a7d6b692.js"><link rel="prefetch" href="/blog/assets/js/49.d8dfe89c.js"><link rel="prefetch" href="/blog/assets/js/50.c134af69.js"><link rel="prefetch" href="/blog/assets/js/51.f1cb3058.js"><link rel="prefetch" href="/blog/assets/js/52.fb7584dc.js"><link rel="prefetch" href="/blog/assets/js/53.5e6bf0ad.js"><link rel="prefetch" href="/blog/assets/js/54.a139237b.js"><link rel="prefetch" href="/blog/assets/js/55.2c8c1bd1.js"><link rel="prefetch" href="/blog/assets/js/56.d09c9904.js"><link rel="prefetch" href="/blog/assets/js/57.ac762da0.js"><link rel="prefetch" href="/blog/assets/js/58.84bdcdb4.js"><link rel="prefetch" href="/blog/assets/js/59.d6c177ba.js"><link rel="prefetch" href="/blog/assets/js/6.acfbb48a.js"><link rel="prefetch" href="/blog/assets/js/60.93b65c4d.js"><link rel="prefetch" href="/blog/assets/js/61.f562ba6c.js"><link rel="prefetch" href="/blog/assets/js/62.3eb3a491.js"><link rel="prefetch" href="/blog/assets/js/63.5175822a.js"><link rel="prefetch" href="/blog/assets/js/65.681bdc18.js"><link rel="prefetch" href="/blog/assets/js/66.85152f7f.js"><link rel="prefetch" href="/blog/assets/js/67.b6ff2ed4.js"><link rel="prefetch" href="/blog/assets/js/68.f115d1bc.js"><link rel="prefetch" href="/blog/assets/js/69.0259fb8a.js"><link rel="prefetch" href="/blog/assets/js/7.1e8f103c.js"><link rel="prefetch" href="/blog/assets/js/70.176336c8.js"><link rel="prefetch" href="/blog/assets/js/9.123bc00f.js"><link rel="prefetch" href="/blog/assets/js/vendors~flowchart.9809e798.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.03f43f65.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme"><header class="navbar"><div class="nav-header"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" class="logo"> <span class="site-name can-hide">
        HOME
      </span></a> <nav class="nav-links can-hide"><ul class="nav-ul"><li class="nav-item"><a href="/blog/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/blog/about/" class="nav-link">About</a></li><li class="nav-item"><a href="/blog/tag/" class="nav-link">Tags</a></li><li class="nav-item"><a href="http://www.cnblogs.com/lewiscutey/" target="_blank" rel="noopener noreferrer" class="nav-link">CSDN</a></li><li class="nav-item"><a href="https://github.com/lewiscutey" target="_blank" rel="noopener noreferrer" class="nav-link">Github</a></li></ul></nav> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></div></header> <div class="sidebar-mask"></div> <!----> <div class="layout-container"><div class="main"><div class="layout-inner"><div class="card"><div class="content-header"><h1 class="page-title">一文速览Vue全栈</h1> <span class="page-timestamp">2019-07-07 22:36:32</span></div> <div class="content default"><blockquote><p>Vue 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以<strong>自底向上逐层应用</strong>，专注于<strong>声明式渲染视图层</strong>，结合<strong>丰富的生态系统和核心插件</strong>，致力于<strong>简单灵活快速驱动SPA、MPA等大小型应用</strong>。</p></blockquote> <p>本文依次介绍 <strong>双向数据绑定</strong>、<strong>计算属性</strong>、<strong>组件</strong>、<strong>事件机制</strong>、<strong>插件机制</strong>、<strong>前端路由</strong>、<strong>状态管理</strong>和<strong>服务端渲染</strong>等。</p> <h2 id="_1-vue实例与数据绑定"><a href="#_1-vue实例与数据绑定" aria-hidden="true" class="header-anchor">#</a> 1. Vue实例与数据绑定</h2> <h3 id="实例"><a href="#实例" aria-hidden="true" class="header-anchor">#</a> 实例</h3> <p><strong>Vue.js应用</strong>的创建很简单，通过构造函数 Vue 就可以创建一个 Vue 的根实例，并启动 Vue；</p> <div class="language- extra-class"><pre class="language-text"><code>var app = new Vue({
    //选项
});
</code></pre></div><p>变量 app 就代表了这个 Vue 实例,事实上几乎所有的代码都是一个对象，用来写入 Vue 实例的选项内的。</p> <p>首先，必不可少的一个选项就是el，el用于指定一个页面中己存在的DOM元素来挂载Vue 实例，它可以是 HTMLElement ，也可以是CSS选择器，比如:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id='app'&gt;&lt;/div&gt;
var app =new Vue({
    el: document.getElementByld('app')  // 或者是'#app'
});
</code></pre></div><p><strong>一个 Vue 应用由一个通过 new Vue() 创建的根Vue实例，以及可选的嵌套的、可复用的组件树组成。</strong></p> <h3 id="数据绑定"><a href="#数据绑定" aria-hidden="true" class="header-anchor">#</a> 数据绑定</h3> <p>当一个 Vue 实例被创建时，它将 data 对象中的所有的属性加入到 Vue 的响应式系统中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p> <p>建议所有会用到的数据都预先在data内声明，这样不至于将数据散落在业务逻辑中，难以维护。
Vue实例本身也代理了 data对象里的所有属性，所以可以这样访问:</p> <div class="language- extra-class"><pre class="language-text"><code>var app = new Vue({
    el: '#app',
    data: {
        a: 2
    }
});
console.log(app.a);  // 2
</code></pre></div><p>除了显式地声明数据外，也可以指向一个己有的变量，并且它们之间默认建立了双向绑定，当修改其中任意一个时，另一个也会一起变化:</p> <div class="language- extra-class"><pre class="language-text"><code>var myData = {
    a: 1
};
var app =new Vue({
    el: '#app',
    data: myData
});
console.log(app.a) ; // 1
//修改属性，原数据也会随之修改
app.a = 2;
console.log(myData.a); // 2
//反之，修改原数据， Vue属性也会修改
myData.a = 3;
console.log(app.a); // 3
</code></pre></div><h3 id="生命周期"><a href="#生命周期" aria-hidden="true" class="header-anchor">#</a> 生命周期</h3> <p>每个 Vue 实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子， 我们可以利用这些钩子，在合适的时机执行我们的业务逻辑。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/7/7/16bcbc821a6e2e73?w=1200&amp;h=3039&amp;f=png&amp;s=50021" alt=""></p> <p>Vue的生命周期大致分为四个阶段：</p> <p><strong>beforeCreate</strong>（此时date、method和el均没有初始化，可以在此加载loading）
<strong>created</strong>（此时date和method初始化完成，但是DOM节点并没有挂载，判断是否有el节点，如果有则编译template，如果没有则使用vm.$mount创建一个默认节点，此时可以在DOM渲染之前进行数据的初始化和method的自执行等）</p> <p><strong>beforeMount</strong>（编译模板，并且将此时在el上挂载一个虚拟的DOM节点）
<strong>mounted</strong>（编译模板，且将真实的DOM节点挂载在el上）</p> <p><strong>beforeUpdate</strong>（在数据有更新时，进入此钩子函数，虚拟DOM被重新创建）
<strong>update</strong>d（数据更新完成时，进入此钩子函数）</p> <p><strong>beforeDestory</strong>（组件销毁前调用，此时将组件上的watchers、子组件和事件都移除掉）
<strong>destoryed</strong>（组件销毁后调用）</p> <p><strong>在创建时，父子组件的生命周期是：</strong>
父组件beforeCreated -&gt; 父组件created -&gt; 父组件beforeMounted -&gt; 子组件beforeCreated -&gt; 子组件created -&gt; 子组件beforeMounted -&gt; 子组件mounted -&gt; 父组件mounted。</p> <p><strong>在销毁时，父子组件的生命周期是：</strong>
父组件beforeDestory -&gt; 子组件beforeDestoryed -&gt; 子组件destoryed -&gt; 父组件destoryed</p> <p>总之记住，父子组件的生命周期遵循：<strong>由外到内，再由内到外</strong>。</p> <div class="language-! extra-class"><pre class="language-text"><code>不要在选项属性或回调上使用箭头函数，vue会自动绑定this的上下文环境。
</code></pre></div><h3 id="模版语法"><a href="#模版语法" aria-hidden="true" class="header-anchor">#</a> 模版语法</h3> <p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</p> <p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p> <p>使用<code>双大括号(Mustache 语法)“{{}}”</code>是最基本的文本插值方法，它会自动将我们双向绑定的数据实时显示出来，</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;span&gt;Message: {{ msg }}&lt;/span&gt;
</code></pre></div><p>如果想显示<code>{{}}</code>标签，而不进行替换，使用v-pre即可跳过这个元素和它的子元素的编译过程，例如 :</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;span v-pre&gt;{{这里的内容是不会被编译的}}&lt;/span&gt;
</code></pre></div><p>在<code>{{}}</code>中，除了简单的绑定属性值外，还可以使用JavaScript表达式进行简单的运算、三元运算等，例如 :</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id='app'&gt;
    {{ number / 10 ))
    {{ isOK ? ’确定’ : ’取消’ }}
    {{ text.split(’,’).reverse().join(’,’) }}
&lt;/div&gt;
</code></pre></div><p>通过使用 <code>v-once</code> 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;span v-once&gt;这个将不会改变: {{ msg }}&lt;/span&gt;
</code></pre></div><p>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写<code>渲染 (render)</code>函数，使用可选的 <code>JSX</code> 语法。</p> <h3 id="指令"><a href="#指令" aria-hidden="true" class="header-anchor">#</a> 指令</h3> <p><strong>指令(Directives)</strong> 是带有 <code>v-</code> 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for是例外情况)。指令的职责是当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。
常用的指令如下：</p> <ul><li><strong>v-cloak</strong></li></ul> <p><strong>v-cloak</strong>不需要表达式，它会在 Vue 实例结束编译时从绑定的 HTML 元素上移除 ，
经常和css的 <strong>display: none</strong>配合使用:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id='app' v-cloak&gt; {{ message }}&lt;/div&gt;
&lt;style&gt;
[v-cloak] {
    display: none;
}
&lt;/style&gt;
</code></pre></div><p>当网速较慢 Vue.js 文件还没加载完时，在页面上会显示{ { message }}的字样，直到 Vue 创建实例、编译模板时， DOM 才会被替换，所以这个过程屏幕是有闪动的,只要加上<strong>v-cloak</strong>就可以避免了。在一般情况下， <strong>v-cloak</strong> 是一个解决初始化慢导致页面闪动的最佳实践，对于简单的项目很实用，但是在具有工程化的项目里，项目的HTML 结构只有一个空的 div元素，剩余的内容都是由路由去挂载不同组件完成的，所以不再需要 <strong>v-cloak</strong>；</p> <ul><li><strong>v-once</strong></li></ul> <p><strong>v-once</strong> 也是一个不需要表达式的指令，作用是定义它的元素或组件只渲染一次，包括元素或组件的所有子节点。首次渲染后，不再随数据的变化重新渲染，将被视为静态内容，例如:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;span v-once&gt;{{ message }}&lt;/div&gt;
</code></pre></div><p><strong>v-once</strong>在业务中也很少使用，当你需要进一步优化性能时，可能会用到。</p> <ul><li><strong>v-html</strong></li></ul> <p>为了输出真正的 HTML，需要使用 v-html 指令;</p> <div class="language- extra-class"><pre class="language-text"><code>var contenthtml = `&lt;span&gt;哈哈大笑😄&lt;/span&gt;`;
&lt;span v-html=&quot;contenthtml&quot;&gt;&lt;/span&gt;
</code></pre></div><div class="language-! extra-class"><pre class="language-text"><code>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值,必要时在服务端进行提前过滤转义。
</code></pre></div><ul><li><strong>v-if</strong></li></ul> <p>用于条件性地渲染一块内容，该指令是惰性的，当初始值为false时dom节点不会进行渲染，是针对dom节点的移除和添加，例如 :</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id='app'&gt;
    &lt;span v-if='false'&gt;{{ message }}&lt;/span&gt;
&lt;/div&gt;
// 会被渲染为以下节点：
&lt;div id='app'&gt;&lt;/div&gt;
</code></pre></div><ul><li><strong>v-show</strong></li></ul> <p><strong>v-show</strong>的用法与<strong>v-if</strong>基本一致，只不过<strong>v-show</strong>是改变元素的<strong>css属性display</strong>。当v-show 表达式的值为 false 时， 元素会隐藏，查看 DOM 结构会看到元素上加载了内联样式 display: none; 例如 :</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id='app'&gt;
    &lt;span v-show='false'&gt;{{ message }}&lt;/span&gt;
&lt;/div&gt;
// 会被渲染为以下节点
&lt;div id='app'&gt;
    &lt;span style=&quot;display: none;”&gt;哈哈大笑😄&lt;/span&gt;
&lt;/div&gt;
</code></pre></div><div class="language-! extra-class"><pre class="language-text"><code>v-show不能在&lt;template&gt;上使用。相比之下， v-if更适合条件不经常改变的场景，因为它切换开销相对较大，而 v-show 适用于频繁切换条件。
</code></pre></div><ul><li><strong>v-else</strong></li></ul> <p><strong>v-else</strong> 元素必须紧跟在带 <strong>v-if</strong> 或者 <strong>v-else-if</strong>的元素的后面，否则它将不会被识别。例如 :</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;span v-if='show'&gt;{{ message.a }}&lt;/span&gt;
&lt;span v-else&gt;{{ message.b }}&lt;/span&gt;
</code></pre></div><ul><li><strong>v-for</strong></li></ul> <p>当需要将一个数组遍历或枚举一个对象循环显示时，就会用到列表渲染指令 <strong>v-for</strong>。它的表达式需结合 in来使用，类似 item in items 的形式，看下面的示例 :</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul&gt;
    &lt;li v-for=”book in books” :key=&quot;book.id&quot;&gt;{{ book.name }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染,所以需要为每个元素设置唯一的<strong>key</strong>。</p> <ul><li><strong>v-bind</strong></li></ul> <p><strong>v-bind</strong>用于动态更新 HTML 元素上的属性，比如 id、class等；</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=”app”&gt;
    &lt;a v-bind:href=”url”〉链接&lt;/a&gt;
    &lt;img v-bind:src=”imgUrl”&gt;
&lt;/div&gt;
</code></pre></div><p>以上是 <strong>v-bind</strong> 最基本的用法，它在 Vue.js 组件中还有着极其重要的作用，可以简写为<code>：</code>；</p> <ul><li><strong>v-on</strong></li></ul> <p><strong>v-on</strong>在事件绑定上，类似原生 JavaScript 的 onclick等写法，也是在 HTML 上进行监昕的,例如：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;button v-on:click=”counter++”&gt;+ 1&lt;/button&gt;
</code></pre></div><p><strong>v-on:click</strong>的表达式可以直接使用 JavaScript 语句，也可以是一个在 Vue实例中 methods选项内的函数名,例如：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;button v-on:click=”handleAdd(1)”&gt;+ 1&lt;/button&gt;

methods: {
    handleAdd: function(count) {
        this.counter += count;
    }
}
</code></pre></div><p>v-on:click调用的方法名后可以不跟括号“()” ;</p> <p>Vue 提供了 一个特殊变量$event，用于访问原生DOM事件，例如下面的实例可以阻止链接打开；</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;a href=”http://www.apple.com” @click=&quot;handleClick ('禁止打开'，$event)&quot;&gt;
打开链接 &lt;/a&gt;

methods: {
    handleClick: function(message, event) {
        event.preventDefault();
    }
}
</code></pre></div><p><strong>v-on</strong>可以简写为<code>@</code>。</p> <ul><li><strong>v-model</strong></li></ul> <p><strong>v-model</strong>用于表单，进行双向数据绑定。例如：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type=”text” id=&quot;name&quot; v-model=&quot;fullname&quot; /&gt;
&lt;p&gt;你好，{{fullname}} !&lt;/p&gt;
</code></pre></div><h3 id="过滤器"><a href="#过滤器" aria-hidden="true" class="header-anchor">#</a> 过滤器</h3> <p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值</strong>和 <strong>v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 在双花括号中 --&gt;
{{ message | capitalize }}

&lt;!-- 在 `v-bind` 中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
</code></pre></div><p>你可以在一个组件的选项中定义本地的过滤器：</p> <div class="language- extra-class"><pre class="language-text"><code>filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}

// 或者在创建 Vue 实例之前全局定义过滤器：
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})
</code></pre></div><p>过滤器可以串联：</p> <div class="language- extra-class"><pre class="language-text"><code>{{ message | filterA | filterB }}
</code></pre></div><p>过滤器是 JavaScript 函数，因此可以接收参数：</p> <div class="language- extra-class"><pre class="language-text"><code>{{ message | filterA('arg1', arg2) }}
</code></pre></div><p>这里，filterA 被定义为接收三个参数的过滤器函数。其中<strong>message 的值</strong>作为第一个参数，<strong>普通字符串 'arg1'</strong> 作为第二个参数，<strong>表达式 arg2 的值</strong>作为第三个参数。</p> <h2 id="_2-计算属性与响应式依赖"><a href="#_2-计算属性与响应式依赖" aria-hidden="true" class="header-anchor">#</a> 2. 计算属性与响应式依赖</h2> <blockquote><p>在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回 一个结果就可以。计算属性还可以依赖多个Vue实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;span&gt;{{fullName}}&lt;/span&gt;
computed: {
    fullName: {
        get: function() {
            return this.firstName + ' ' + this.lastName;
        },
        set: function(newValue) {
            var names= newValue.split (' ') ;
            this.firstName = names[O);
            this.lastName = names[names.length - 1];
        }
    }
}
</code></pre></div><p>我们可以通过在表达式中调用方法来达到同样的效果:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;span&gt;{{getName()}}&lt;/span&gt;
methods: {
    getName: function() {
        return this.firstName + ' ' + this.lastName;
    }
}
</code></pre></div><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性</strong>是基于它们的<strong>响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。</p> <p>虽然<strong>计算属性</strong>在大多数情况下更合适，但有时也需要一个自定义的<strong>侦听器</strong>。这就是为什么 Vue 通过 <strong>watch</strong>选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p> <div class="language- extra-class"><pre class="language-text"><code>watch: {
    message(newvalue, oldValue) {
        newvalue &amp;&amp; this.getNewMessage();
    }
}
</code></pre></div><h2 id="_3-组件"><a href="#_3-组件" aria-hidden="true" class="header-anchor">#</a> 3. 组件</h2> <p>组件是可复用的 Vue 实例，通常一个应用会以一棵嵌套的组件树的形式来组织：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/7/7/16bcc204e4428c24?w=1406&amp;h=544&amp;f=png&amp;s=6202" alt=""></p> <p><a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener noreferrer">组件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ( Component)是 Vue 最核心的功能，也是整个框架设计最精彩的地方，当然也是最难 掌握的。组件需要注册后才可以使用，注册有全局注册和局部注册两种方式。全局注册后， 任何 Vue 实例都可以使用。</p> <p>全局注册示例代码如下 :</p> <div class="language- extra-class"><pre class="language-text"><code>Vue.component(’my-component’, {
    //选项
})
</code></pre></div><p>在 Vue 实例中，使用 components选项可以局部注册组件，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件，使组件可以嵌套。示例代码如下:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=”app”&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
var Child = {
    template: '&lt;div&gt;局部注册组件的内容&lt;/div&gt;'
};
components: {
    ’my-component’: Child
}
&lt;/script&gt;
</code></pre></div><p>Vue 组件的模板在某些情况下会受到HTML的限制，比如<code>&lt;table&gt;</code>内规定只允许是<code>&lt;tr&gt;</code>、<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>等这些表格元素，所以在<code>&lt;table&gt;</code>内直接使用组件是无效的。这种情况下可以使用特殊的is属性来挂载组件，示例代码如下 :</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=”app”&gt;
    &lt;table&gt;
        &lt;tbody is=”my-component”&gt;&lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;
&lt;script&gt;
var Child = {
    template: '&lt;div&gt;局部注册组件的内容&lt;/div&gt;'
};
components: {
    ’my-component’: Child
}
&lt;/script&gt;
</code></pre></div><div class="language-! extra-class"><pre class="language-text"><code>常见的限制元素还有&lt;ul&gt;、&lt;ol&gt;、&lt;select&gt;；如果使用字符串模板是不受限制的；
</code></pre></div><p>除了 template选项外，组件中还可以像 Vue实例那样使用其他的选项，比如 <strong>data</strong>、 <strong>computed</strong>、 <strong>methods</strong> 等。但是在使用 <strong>data</strong> 时和实例稍有区别， <strong>data</strong> 必须是函数，然后将数据 return 出去， 例如:</p> <div class="language- extra-class"><pre class="language-text"><code>Vue.component('my-component', {
    template: '&lt;div&gt;{{ message }}&lt;/div&gt;',
    data: function() {
        return {
            message: 'aaa'
        }
    }
});
</code></pre></div><p><strong>props传递数据、 events触发事件和slot内容分发就构成了Vue组件的3个API来源，再复 杂的组件也是由这 3 部分构成的。</strong></p> <ul><li><p>props</p> <blockquote><p>组件不仅仅是要把模板的内容进行复用，更重要的是组件间要进行通信。通常父组件的模板 中包含子组件，父组件要正向地向子组件传递数据或参数，子组件接收到后根据参数的不同来渲染不同的内容或执行操作。这个正向传递数据的过程就是通过 <strong>props</strong> 来实现的。</p></blockquote></li></ul> <p>在组件中，使用选项 props 来声明需要从父级接收的数据， props 的值可以是两种， 一种是字符串数组，一种是对象:</p> <div class="language- extra-class"><pre class="language-text"><code>// 字符串数组
Vue.component ('my-component', {
    props: [ ’ message ’ ] ,
    template: ’&lt;div&gt;{{ message }}&lt;/div&gt;’
});
// 对象形式
Vue.component ('my-component', {
    props: {
        //必须是数字类型
        propA : Number,
        //必须是字符串或数字类型
        propB : [String , Number],
        //布尔值，如果没有定义，默认值就是 true
        propC: {
            type: Boolean,
            default: true
        },
        //数字，而且是必传
        propD: {
            type: Number,
            required: true
        },
        //如果是数组或对象，默认值必须是一个函数来返回
        propE: {
            type: Array,
            default: function() {
                return [];
            }
        }
    } ,
    template: ’&lt;div&gt;{{ message }}&lt;/div&gt;’
});
</code></pre></div><ul><li>events</li></ul> <p>用集中式的事件中间件可以做到简单的数据传递，这会让组件之间的通信非常顺利，即使是兄弟组件。因为 Vue 通过事件发射器接口执行实例，实际上你可以使用一个空的 Vue 实例，通过单独的事件中心管理组件间的通信：</p> <div class="language- extra-class"><pre class="language-text"><code>var eventHub = new Vue();
</code></pre></div><p>然后在组件中，可以使用 <code>$emit</code>, <code>$on</code>, <code>$off</code> 分别来分发、监听、取消监听事件：</p> <div class="language- extra-class"><pre class="language-text"><code>eventHub.$emit('delete', id);
eventHub.$on('delete', this.delete);
eventHub.$off('delete', this.delete)
</code></pre></div><ul><li>slot</li></ul> <p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 Web Components 规范草案，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p> <p>-<strong>普通插槽</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>// 父组件
&lt;submit-button&gt;save&lt;/submit-button&gt;
// 子组件
&lt;button type=&quot;submit&quot;&gt;
  &lt;slot&gt;Submit&lt;/slot&gt;
&lt;/button&gt;

// 最终渲染
&lt;button type=&quot;submit&quot;&gt;
  Save
&lt;/button&gt;
</code></pre></div><p>-<strong>具名插槽</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>// 父组件
&lt;base-layout&gt;
 &lt;template v-slot:header&gt;
   &lt;h1&gt;Here might be a page title&lt;/h1&gt;
 &lt;/template&gt;

 &lt;template v-slot:default&gt;
   &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
   &lt;p&gt;And another one.&lt;/p&gt;
 &lt;/template&gt;

 &lt;template v-slot:footer&gt;
   &lt;p&gt;Heres some contact info&lt;/p&gt;
 &lt;/template&gt;
&lt;/base-layout&gt;
// 子组件
&lt;div class=&quot;container&quot;&gt;
 &lt;header&gt;
   &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
 &lt;/header&gt;
 &lt;main&gt;
   &lt;slot&gt;&lt;/slot&gt;
 &lt;/main&gt;
 &lt;footer&gt;
   &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
 &lt;/footer&gt;
&lt;/div&gt;

// 最终渲染
&lt;div class=&quot;container&quot;&gt;
 &lt;header&gt;
   &lt;h1&gt;Here might be a page title&lt;/h1&gt;
 &lt;/header&gt;
 &lt;main&gt;
   &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
   &lt;p&gt;And another one.&lt;/p&gt;
 &lt;/main&gt;
 &lt;footer&gt;
   &lt;p&gt;Heres some contact info&lt;/p&gt;
 &lt;/footer&gt;
&lt;/div&gt;
</code></pre></div><p>-<strong>作用域插槽</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>// 父组件
&lt;current-user&gt;
  &lt;template v-slot:default=&quot;slotProps&quot;&gt;
    {{ slotProps.user.firstName }}
  &lt;/template&gt;
&lt;/current-user&gt;

// 子组件
&lt;span&gt;
  &lt;slot v-bind:user=&quot;user&quot;&gt;
    {{ user.lastName }}
  &lt;/slot&gt;
&lt;/span&gt;
</code></pre></div><p>插槽对于组件意义非凡，可以自定义拓展实现很多复杂的业务场景，且低耦合；</p> <ul><li><p>通信方式</p> <p>-<strong>props/$emit</strong></p></li></ul> <p>父子组件进行通信最常用这种方式：</p> <div class="language- extra-class"><pre class="language-text"><code>// 父组件
&lt;template&gt;
    &lt;child :updateTitle='updateTitle'&gt;&lt;/child&gt;
&lt;/template&gt;
&lt;script&gt;
export {
    data: {
        return {
            title: '我是父组件'
        }
    },
    methods: {
        updateTitle(value) {
            this.title = value;
        }
    }
}
&lt;/script&gt;
// 子组件
&lt;template&gt;
  &lt;header&gt;
    &lt;h1 @click=&quot;changeTitle&quot;&gt;{{title}}&lt;/h1&gt;
  &lt;/header&gt;
&lt;/template&gt;
&lt;script&gt;
export {
    props: {
        title: {
            type: String,
            default: '我是父组件'
        }
    }，
    methods: {
        changeTitle() {
            this.$emit('updateTitle', '我是子组件');
        }
    }
}
&lt;/script&gt;
</code></pre></div><p>-<strong>eventBus</strong></p> <p>父子、兄弟组件之间都可以使用这种方式：</p> <div class="language- extra-class"><pre class="language-text"><code>var Event=new Vue();
Event.$emit(事件名,数据);
Event.$on(事件名,data =&gt; {});
</code></pre></div><p><code>$emit</code>负责分发事件，$on负责监听了自定义事件，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。</p> <p>-<strong>vuex</strong></p> <p>Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 进行，Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action，但 Action 也是无法直接修改 State 的，还是需要通过 Mutation 来修改 State 的数据。最后，根据 State 的变化，渲染到视图上。</p> <p>一般用于比较复杂的大中型应用，一个应用只有一个store，通过插件的机制注入应用本身，下面的全部组件都可以访问到store中的数据，便于数据的管理和追踪变化；</p> <p>-<strong><code>$attrs</code>/$listeners</strong></p> <p><code>$attrs</code>包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 interitAttrs 选项一起使用。</p> <p><code>$listeners</code>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件。</p> <div class="language- extra-class"><pre class="language-text"><code>// 父组件
&lt;template&gt;
    &lt;child :foo=&quot;foo&quot; :boo=&quot;boo&quot;  title=&quot;天道酬勤Lewis&quot;&gt;&lt;/child&gt;
&lt;/template&gt;
// 子组件
&lt;template&gt;
    &lt;p&gt;boo: {{ boo }}&lt;/p&gt;
    &lt;p&gt;child: {{ $attrs }}&lt;/p&gt;
&lt;/template&gt;
</code></pre></div><div class="language-! extra-class"><pre class="language-text"><code>Vue2.4 提供了$attrs,$listeners来传递数据与事件，跨级组件之间的通讯变得更简单。
简单来说：$attrs与$listeners 是两个对象，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。
</code></pre></div><p>-<strong>provide/inject</strong></p> <p>Vue2.2.0 新增 API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，在上下游关系成立的时间里始终生效。一言而蔽之：<strong>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject来注入变量</strong>。</p> <p><strong>provide / inject</strong> API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p> <div class="language- extra-class"><pre class="language-text"><code>// 父组件
export default {
  provide: {
    name: '天道酬勤Lewis'
  }
}
// 子组件
export default {
  inject: ['name'],
  mounted () {
    console.log(this.name);  // 天道酬勤Lewis
  }
}
</code></pre></div><div class="language-! extra-class"><pre class="language-text"><code>provide 和 inject 绑定并不是可响应的,这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。
</code></pre></div><h2 id="_4-事件机制"><a href="#_4-事件机制" aria-hidden="true" class="header-anchor">#</a> 4. 事件机制</h2> <p>Vue定义了四种添加事件监听的方法：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/7/7/16bcc7db75abb919?w=675&amp;h=348&amp;f=png&amp;s=17087" alt=""></p> <ul><li>$on</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Vue.prototype.$on = function (event, fn) {
    var this$1 = this;
    var vm = this;
    //如果传参event是数组，递归调用$on
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i &lt; l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // 这里在注册事件的时候标记bool值也就是个标志位来表明存在钩子，而不需要通过哈希表的方法来查找是否有钩子，这样做可以减少不必要的开销，优化性能。
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
};
</code></pre></div><ul><li>$once</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      //在第一次执行的时候将该事件销毁
      vm.$off(event, on);
      //执行注册的方法
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
};
</code></pre></div><ul><li>$emit</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  Vue.prototype.$emit = function (event) {
    var vm = this;
    {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) {
        tip(
          &quot;Event \&quot;&quot; + lowerCaseEvent + &quot;\&quot; is emitted in component &quot; +
          (formatComponentName(vm)) + &quot; but the handler is registered for \&quot;&quot; + event + &quot;\&quot;. &quot; +
          &quot;Note that HTML attributes are case-insensitive and you cannot use &quot; +
          &quot;v-on to listen to camelCase events when using in-DOM templates. &quot; +
          &quot;You should probably use \&quot;&quot; + (hyphenate(event)) + &quot;\&quot; instead of \&quot;&quot; + event + &quot;\&quot;.&quot;
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      //将类数组的对象转换成数组
      cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i &lt; l; i++) {
        try {
          //触发当前实例上的事件，附加参数都会传给监听器回调。
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, (&quot;event handler for \&quot;&quot; + event + &quot;\&quot;&quot;));
        }
      }
    }
    return vm
};
</code></pre></div><ul><li>$off</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;
    var vm = this;
    // 如果没有参数，关闭全部事件监听器
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // 关闭数组中的事件监听器
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i &lt; l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm
    }
    // 具体的某个事件
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    //  fn回调函数不存在，将事件监听器变为null，返回vm
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // 回调函数存在
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          // 移除 fn 这个事件监听器
          cbs.splice(i$1, 1);
          break
        }
      }
    }
    return vm
};
</code></pre></div><ul><li>事件修饰符</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre></div><h2 id="_5-插件机制"><a href="#_5-插件机制" aria-hidden="true" class="header-anchor">#</a> 5. 插件机制</h2> <p>Vue提供了插件机制，可以在全局添加一些功能。它们可以简单到几个方法、属性，也可以 很复杂，比如一整套组件库。
注册插件需要一个公开的方法 install，它的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象,示例代码如下:</p> <div class="language- extra-class"><pre class="language-text"><code>MyPlugin.install = function (Vue, options) {
    //全局注册组件(指令等功能资源类似〉
    Vue.component ('component-name'，{
        //组件内容
    }),
    //添加实例方法
    Vue.prototype.$Notice = function() {
        //逻辑 ...
    },
    //添加全局方法或属性
    Vue.globalMethod = function() {
        //逻辑 ...
    },
    //添加全局混合
    Vue.mixin ({
        mounted: function() {
            //逻辑 ...
        }
    })，
    //添加全局过滤器
    Vue.directive('my-directive', {
        bind (el, binding, vnode, oldVnode) {
            // 逻辑...
        }
    }
  })
};
// 通过 Vue.use()来使用插件:
Vue.use(MyPlugin);
// 或 
Vue.use(MyPlugin, {
    // 参数选项
});
</code></pre></div><p>绝大多数情况下，开发插件主要是通过NPM发布后给别人使用的，在自己的项目中可以直接在入口调用以上方法 ，无须多一步注册和使用的步骤 。</p> <h2 id="_6-前端路由vue-router"><a href="#_6-前端路由vue-router" aria-hidden="true" class="header-anchor">#</a> 6. 前端路由Vue-router</h2> <blockquote><p><strong>Vue Router</strong> 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p></blockquote> <p>包含的功能有：</p> <ul><li>嵌套的路由/视图表</li> <li>模块化的、基于组件的路由配置</li> <li>路由参数、查询、通配符</li> <li>基于 Vue.js 过渡系统的视图过渡效果</li> <li>细粒度的导航控制</li> <li>带有自动激活的 CSS class 的链接</li> <li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li> <li>自定义的滚动条行为</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)

// 1. 定义 (路由) 组件。
// 可以从其他文件 import 进来
const Foo = { template: '&lt;div&gt;foo&lt;/div&gt;' }
const Bar = { template: '&lt;div&gt;bar&lt;/div&gt;' }

// 2. 定义路由
// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是
// 通过 Vue.extend() 创建的组件构造器，
// 或者，只是一个组件配置对象。
const routes = [
  { path: '/foo', component: Foo },
  { path: '/bar', component: Bar }
]

// 3. 创建 router 实例，然后传 `routes` 配置
// 你还可以传别的配置参数, 不过先这么简单着吧。
const router = new VueRouter({
  routes // (缩写) 相当于 routes: routes
})

// 4. 创建和挂载根实例。
// 记得要通过 router 配置参数注入路由，
// 从而让整个应用都有路由功能
const app = new Vue({
  router
}).$mount('#app')
</code></pre></div><p><strong>vue-router</strong> 默认 <strong>hash</strong> 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载,这种模式利用监听<strong>onhashchange</strong>事件，来实现页面的跳转；如果不想要很丑的 hash，我们可以用路由的 <strong>history</strong> 模式，这种模式充分利用 <strong>history.pushState</strong> API 来完成 URL 跳转而无须重新加载页面。</p> <div class="language- extra-class"><pre class="language-text"><code>const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
</code></pre></div><p>当你使用 history 模式时，URL 就像正常的 url，例如     <code>http://yoursite.com/user/id</code>，也好看！</p> <p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <code>http://oursite.com/user/id</code> 就会返回 404，这就不好看了。</p> <p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p> <h2 id="_7-状态管理vuex"><a href="#_7-状态管理vuex" aria-hidden="true" class="header-anchor">#</a> 7. 状态管理Vuex</h2> <blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote> <p>以下是一个完整的vuex理念的简单示意：
<img src="https://user-gold-cdn.xitu.io/2019/7/7/16bcca170bba2f2a?w=701&amp;h=551&amp;f=png&amp;s=8112" alt=""></p> <ul><li>state，驱动应用的数据源；</li> <li>view，以声明方式将 state 映射到视图；</li> <li>actions，响应在 view 上的用户输入导致的状态变化;</li> <li>mutations, 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation;</li></ul> <p>一般为了逻辑清晰，会按页面对store进行module的区分，一个完整的module-store如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const moduleA = {
    state: { ... },
    mutations: { . . . },
    actions: { ... ),
    getters: { ... )
};
</code></pre></div><div class="language-! extra-class"><pre class="language-text"><code>使用Vuex进行数据管理是有一定难度的，如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。
</code></pre></div><h2 id="_8-服务端渲染nuxt-js"><a href="#_8-服务端渲染nuxt-js" aria-hidden="true" class="header-anchor">#</a> 8. 服务端渲染Nuxt.js</h2> <blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。</p></blockquote> <p>与传统 <strong>SPA</strong> (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (<strong>SSR</strong>) 的优势主要在于：</p> <ol><li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</li> <li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</li></ol> <p><strong>Nuxt.js</strong>十分简单易用,天然为Vue而生(<strong>Next.js</strong>为<strong>React</strong>而生);Nuxt.js 是一个基于 Vue.js 的通用应用框架，预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。一个简单的项目只需将 nuxt 添加为依赖组件即可，更多细节<a href="https://zh.nuxtjs.org/guide" target="_blank" rel="noopener noreferrer">请戳这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>;</p></div> <div class="content page-nav"><p class="inner"><span class="prev">←
          <a href="/blog/blog/vue-react.html" class="prev">Vue和React的一些区别</a></span> <span class="next"><a href="/blog/blog/webpcak.html">一文速览Webpack</a>→
        </span></p></div></div> <!----></div> <div class="tool-group"><!----></div></div></div> <footer class="footer"><span>如果说人生是一场旅行，而我是这场旅行的主人!</span></footer></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.426b1919.js" defer></script><script src="/blog/assets/js/8.723e2475.js" defer></script><script src="/blog/assets/js/3.79418191.js" defer></script><script src="/blog/assets/js/16.d48bf774.js" defer></script><script src="/blog/assets/js/19.ff47a288.js" defer></script><script src="/blog/assets/js/13.7908793c.js" defer></script><script src="/blog/assets/js/64.fcc0d5d9.js" defer></script><script src="/blog/assets/js/5.da195e96.js" defer></script>
  </body>
</html>
